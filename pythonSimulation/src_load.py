#!/usr/bin/python3
import numpy as np
from enum import Enum, auto

class L_model(Enum):
    LINEAR_SAT = auto()
    REMANENT = auto()

Lcomb_H_INCR = np.array([0.00668425, 0.00697254, 0.00725637, 0.00752203, 0.00775547,
       0.00794351, 0.008075  , 0.00814194, 0.00814026, 0.00807029,
       0.00793671, 0.00774809, 0.007516  , 0.00725386, 0.00697561,
       0.00669444, 0.00642166, 0.00616591, 0.00593271, 0.0057244 ,
       0.00554051, 0.00537824, 0.00523333, 0.00510076, 0.0049756 ,
       0.00485357, 0.00473148, 0.00460745, 0.00448091, 0.00435243,
       0.00422345, 0.00409593, 0.00397202, 0.00385374, 0.00374277,
       0.0036403 , 0.00354698, 0.00346292, 0.00338779, 0.00332089,
       0.00326132, 0.00320802, 0.00315996, 0.00311611, 0.00307559,
       0.00303761, 0.00300154, 0.00296687, 0.00293322, 0.00290029,
       0.0028679 , 0.00283588, 0.00280413, 0.00277261, 0.00274125,
       0.00271005, 0.00267897, 0.00264801, 0.00261716, 0.00258642,
       0.00255579, 0.00252527, 0.00249486, 0.00246455, 0.00243435,
       0.00240426, 0.00237427, 0.00234439, 0.00231462, 0.00228495,
       0.00225539, 0.00222594, 0.00219659, 0.00216735, 0.00213821,
       0.00210918, 0.00208026, 0.00205144, 0.00202273, 0.00199413,
       0.00196564, 0.00193725, 0.00190896, 0.00188078, 0.00185271,
       0.00182475, 0.00179689, 0.00176914, 0.0017415 , 0.00171396,
       0.00168653, 0.0016592 , 0.00163198, 0.00160487, 0.00157786,
       0.00155096, 0.00152417, 0.00149748, 0.0014709 , 0.00144443,
       0.00141806, 0.0014038 , 0.00138965, 0.0013756 , 0.00136166])
Lcomb_H_DECR = np.array([0.00668425, 0.0064285 , 0.00619529, 0.00598699, 0.00580309,
       0.00564083, 0.00549592, 0.00536335, 0.00523819, 0.00511616,
       0.00499406, 0.00487003, 0.00474349, 0.00461502, 0.00448604,
       0.00435852, 0.00423461, 0.00411633, 0.00400536, 0.00390289,
       0.00380957, 0.00372551, 0.00365038, 0.00358348, 0.0035239 ,
       0.00347061, 0.00342255, 0.0033787 , 0.00333818, 0.0033002 ,
       0.00326412, 0.00322946, 0.0031958 , 0.00316288, 0.00313048,
       0.00309846, 0.00306672, 0.0030352 , 0.00300384, 0.00297263,
       0.00294155, 0.00291059, 0.00287975, 0.00284901, 0.00281838,
       0.00278786, 0.00275745, 0.00272714, 0.00269694, 0.00266685,
       0.00263686, 0.00260698, 0.00257721, 0.00254754, 0.00251798,
       0.00248852, 0.00245918, 0.00242993, 0.0024008 , 0.00237177,
       0.00234285, 0.00231403, 0.00228532, 0.00225672, 0.00222822,
       0.00219983, 0.00217155, 0.00214337, 0.0021153 , 0.00208734,
       0.00205948, 0.00203173, 0.00200408, 0.00197655, 0.00194911,
       0.00192179, 0.00189457, 0.00186746, 0.00184045, 0.00181355,
       0.00178676, 0.00176007, 0.00173349, 0.00170702, 0.00168065,
       0.00165439, 0.00162824, 0.00160219, 0.00157625, 0.00155041,
       0.00152468, 0.00149906, 0.00147355, 0.00144814, 0.00142283,
       0.00139764, 0.00137255, 0.00134757, 0.00132269, 0.00129792,
       0.00127325, 0.0012607 , 0.00124825, 0.0012359 , 0.00122366])

class sourceDC:
    # simple capacitor model

    def __init__(self, C=6*1100e-6, T=1/10e3, V0=30):
        self.C = C
        self.T = T
        self.v = V0

    def step(self, i):
        self.v += 1/self.C * i*self.T
        return self.v


class loadRL:

    def __init__(self, L=200e-6, R=0.1, T=1/10e3, I0=0, model=L_model.LINEAR_SAT):
        self.L = L
        self.R = R
        self.T = T
        self.i = I0
        self.i_prev = 0
        self.model = model  # linear inductor or saturating when L is a matrix

    def step(self, v):

        if self.model==L_model.LINEAR_SAT:
            if len(self.L) == 1:
                L = self.L[0]
            else:  # nonlinear inductance matrix
                L = np.interp(self.i, self.L[:,0], self.L[:,1])
        elif self.model==L_model.REMANENT:  # saturating inductor with remanence
            N = len(Lcomb_H_INCR)
            idx = int(abs(self.i)*10)
            idx = np.clip(idx, 0, N-1)
            current_increasing = False
            if self.i > self.i_prev:
                current_increasing = True

            if    (current_increasing and self.i>=0) \
                or ( not current_increasing and self.i<0):
                L = 2*Lcomb_H_INCR[idx]
            else:
                L = 2*Lcomb_H_DECR[idx]
            self.i_prev = self.i

        if len(self.R) == 1:
            R = self.R[0]
        else:  # nonlinear resistance matrix for modelling resistance increase in inductor
            R = np.interp(self.i, self.R[:,0], self.R[:,1])

        self.i += (v-self.i*R)*self.T/L
        return self.i
